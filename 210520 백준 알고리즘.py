#1037 약수
#N의 진짜 약수는 N의 약수 중에서 1과 N을 제외한 것.
#N의 진짜 약수가 모두 주어졌을 때, N을 구하는 문제
'''
진짜 약수의 최댓값 최솟값를 구하면 항상 N이 나올 것.
입력으로 주어진 수의 최댓값과 최솟값을 곱해주면 N이 나올 거다.
시간 복잡도는? N의 진짜 약수의 개수를 M개로 놓으면, 입력으로
M개. 최소값 구하는 시간 o(M), 최댓값 구하는 시간 o(M).
최솟값 구하기 + 최댓값 구하기 M + M = 2M. 시간 복잡도는 o(M)
'''

#17427 약수의 합 2
#f(A) = A 약수의 합
#g(N) = f(1) + f(2) + ... + f(N)
#N이 주어졌을 때, g(N)을 구하는 문제
#1 <= N <= 1,000,000
# 시간제한 0.5초
'''
f(A) 하나 구하는데 걸리는 시간이 얼마나일까?
배수의 반대는 약수라는 아이디어를 활용하자.

- N 이하의 자연수 중에서 1을 약수로 갖는 수의 개수는 N/1개
- N 이하의 자연수 중에서 2을 약수로 갖는 수의 개수는 N/2개
- N 이하의 자연수 중에서 3을 약수로 갖는 수의 개수는 N/3개
...
- N 이하의 자연수 중에서 1을 약수로 갖는 수의 개수는 N/i개
ex)
1 1
2 1 2
3 1 3
4 1 2 4
5 1 5
6 1 2 3 6
7 1 7
....
g(N) = [N/1]*1 + [N/2]*2 + [N/3]*3 + ... + [N/(N-1)]*(N-1) + [N/N]*N

이 방법이 훨씬 좋은 이유는, 시간 절약이 많이 됨. 식 하나하나가 복잡도가 1이라는 것.
이 식을 몇번 할까? 1을 N번 하니까 O(N)으로 해결 가능!

코드
n = int(input())
ans = 0
for i in range(1, n + 1):
    ans += (n//i) * i
print(ans)
'''
#17425 약수의 합
#f(A) = A 약수의 합
#g(N) = f(1) + f(2) + ... + f(N)
#N이 주어졌을 때, g(N)을 구하는 문제
#1 <= 테스트 케이스의 개수 <= 100,000
#1 <= N <= 1,000,000
# 시간제한 0.5초
'''
앞서 약수의 합2에서 배우게 된 것은, g(N)을 구하는데 걸리는 시간은 O(N).
테스트 케이스의 개수마다 구하면 되니까, 시간복잡도는 O(TN)임.
근데 10만이잖아. 10만 * 100만 = 1000억이고. 1000초를 주진 않잖아?
앞서 했던 방법으론 풀 수가 없다.

테스트 케이스 방식 문제를 풀 때 조심해야할 점.
=> 변하지 않는 값은 매번 테스트 케이스마다 구하는 게 아니라, 한번 구해주고,
그 다음부터는 그냥 이용해주는 방식 사용해야함.
이 방식에서는 모든 g(N)을 다 구할 것. 그럼 O(N) 또는 O(루트N)인데 이걸 빠르게 할 거임.
어떻게 빠르게? 배수 아이디어를 활용해서!

- N = A*B로 나타낼 수 있을 때
- A와 B는 N의 약수이다.
- N은 A와 B의 배수이다.

g(N) = N의 약수의 합
D[i] = g[i]로 해볼 것. 모든 D[i]를 구하기 위해선 i의 약수를 모두 구한다.

N/2 + N/3 + ... + N/N-1 + N/N 이니까, 이것의 시간 복잡도는 NlogN 이다.

1. D를 모두 구하는 부분.
2. 입출력을 하면서 답을 출력하는 부분.

앞에서부터 누적해서 답을 미리 구해놓았다.
그 다음 해야할 건 각 테스트 케이스에 맞춰 입력받고
입력받은 수가 N이면 그때 g(N)을 출력하면 됨.

코드

MAX = 1000000
d = [1] * (MAX+1)
s = [0] * (MAX+1)
for i in range(2, MAX + 1):
    j = 1
    while i*j <= MAX:
        d[i*j] += i
        j += 1
for i in range(1,MAX+1):
    s[i] = s[i-1] + d[i]
t = int(input())
ans = []
for x in range(t):
    n = int(input()):
    ans.append(s[n])
print('\n'.join(map(str,ans))+'\n')










