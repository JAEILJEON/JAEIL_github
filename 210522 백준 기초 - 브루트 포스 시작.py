### 브루트 포스 알고리즘 ###
'''
브루트 포스는 모든 경우의 수를 다 해보는 것이다. o(방법의 수 * 시도하는 복잡도)
가장 중요한 것은 이 경우의 수가 몇가지 나오는지 알아보는 것이 중요.
ex) 비밀번호가 4자리 숫자인 자물쇠의 비밀번호를 까먹었다면, 0000~9999까지 1만가지.
방법 1개 : 1초라면, 1만초 걸림. 약 3시간 정도하면 풀 수 있다.
근데 만약 12자리라면 ㅋㅋㅋ....? 1조가지야... 3만년 걸린다.

브루트 포스는 똑같은 문제에도 ,방법의 개수 크기에 따라 가능 여부가 달라짐.
3가지 단계가 필요. (모든 방법을 시도해보는 알고리즘이기 때문)

1단계 문제의 가능한 경우의 수를 계산해본다. - 사람이 직접 계산해보는 것

2단계 가능한 모든 방법을 다 만들어본다 - 2번부터 코드로 구현
    - 하나도 빠짐없이 다 만들어야함.
    - 대표적으로 그냥 다 해보는 방법, for문, 순열, 재귀호출(가장 중요), 비트마스크 사용 등..
    
3단계 각각의 방법을 이용해 답을 구해본다.
    - 여긴 보통 어렵지 않음.

#경우의 수

- n명의 사람이 한 줄로 서는 경우의 수 -> n!
- n명의 사람 중에서 대표 2 명을 뽑는 경우의 수 -> nC2 = n(n-1)/2 = o(n**2)
- n명의 사람 중에서 대표 3 명을 뽑는 경우의 수 -> nC3 = n(n-1)(n-2)/3*2*1 = o(n**3)
- n명의 사람 중에서 반장 1명 부반장 1명 뽑는 경우의 수 -> n(n-1) = o(n**2)
- n명의 사람이 있을 때, 각 사람이 영화를 볼지, 보지 않을지 결정한다. 가능한 조합 수 -> 2**n

2단계
2309 - 일곱난쟁이
# 아홉명의 난쟁이 중 일곱명의 난쟁이를 찾는 문제
# 일곱 난쟁이의 키의 합은 100.

1. 그냥 다 해보기
1) 9명 중에 7명 찾기 2) 9명 중에 2명 찾기

3085 - 사탕게임
# n * n 크기의 테이블에 사탕이 있다.
# 인접한 두 칸을 고르고, 사탕을 교환한다.
# 그 다음, 같은 색으로 이루어져 있는 가장 긴 연속 부분 행 또는 열을 고르는 문제


